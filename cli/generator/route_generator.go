package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// HandlerInfo 处理器信息
type HandlerInfo struct {
	Type    string `json:"type"`    // 处理器类型
	VarName string `json:"varName"` // 变量名
}

// RouteGenerator 路由生成器
type RouteGenerator struct {
	routes []RouteInfo
}

// NewRouteGenerator 创建新的路由生成器
func NewRouteGenerator(routes []RouteInfo) *RouteGenerator {
	return &RouteGenerator{
		routes: routes,
	}
}

// Generate 生成路由注册文件
func (rg *RouteGenerator) Generate(outputPath string) error {
	// 按包分组路由
	packageRoutes := rg.groupRoutesByPackage()

	// 生成路由注册代码
	content, err := rg.generateRouteContent(packageRoutes)
	if err != nil {
		return fmt.Errorf("生成路由内容失败: %v", err)
	}

	// 确保输出目录存在
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %v", err)
	}

	// 写入文件
	return os.WriteFile(outputPath, []byte(content), 0644)
}

// groupRoutesByPackage 按包分组路由
func (rg *RouteGenerator) groupRoutesByPackage() map[string][]RouteInfo {
	packageRoutes := make(map[string][]RouteInfo)

	for _, route := range rg.routes {
		packageRoutes[route.Package] = append(packageRoutes[route.Package], route)
	}

	return packageRoutes
}

// generateRouteContent 生成路由内容
func (rg *RouteGenerator) generateRouteContent(packageRoutes map[string][]RouteInfo) (string, error) {
	tmpl := `// Code generated by owl route scanner. DO NOT EDIT.
package route

import (
	"bit-labs.cn/owl/contract/foundation"
	"github.com/gin-gonic/gin"
{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

// AutoGeneratedRoutes 自动生成的路由注册函数
// 注意：在调用此函数之前，请确保已经调用了 SubAppAdmin.AutoGeneratedBinds() 来注册所有依赖
func AutoGeneratedRoutes(application foundation.Application, appName string) {
	err := application.Invoke(func(
		engine *gin.Engine,
{{- range .Handlers }}
		{{ .VarName }} *{{ .Type }},
{{- end }}
	) {
		// API 路由组
		gv1 := engine.Group("/api/v1")
		
{{- range .PackageGroups }}
		// {{ .PackageName }} 模块路由
		{
{{- range .Routes }}
			// {{ .Summary }}{{ if .Description }} - {{ .Description }}{{ end }}
			gv1.{{ .Method }}("{{ .CleanPath }}", {{ .HandlerCall }})
{{- end }}
		}
{{- end }}
	})
	if err != nil {
		panic(err)
	}
}
`

	data := rg.prepareTemplateData(packageRoutes)

	t, err := template.New("routes").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var buf strings.Builder
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// prepareTemplateData 准备模板数据
func (rg *RouteGenerator) prepareTemplateData(packageRoutes map[string][]RouteInfo) map[string]interface{} {
	// 收集所有处理器和导入
	handlerMap := make(map[string]HandlerInfo)
	importSet := make(map[string]bool)

	// 为每个路由设置处理器变量
	for pkg, routes := range packageRoutes {
		for i, route := range routes {
			handlerType, varName, importPath := rg.inferHandlerInfo(route.Package, route.HandlerType)
			handlerMap[handlerType] = HandlerInfo{
				Type:    handlerType,
				VarName: varName,
			}

			// 收集导入路径
			if importPath != "" {
				importSet[importPath] = true
			}

			// 设置路由的处理器变量和调用方法
			routes[i].HandlerVar = varName
			routes[i].HandlerCall = fmt.Sprintf("%s.%s", varName, route.HandlerMethod)
		}
		packageRoutes[pkg] = routes
	}

	// 转换处理器映射为切片
	handlers := make([]HandlerInfo, 0, len(handlerMap))
	for _, handler := range handlerMap {
		handlers = append(handlers, handler)
	}

	// 转换导入集合为切片
	imports := make([]string, 0, len(importSet))
	for imp := range importSet {
		imports = append(imports, imp)
	}

	// 准备包组数据
	packageGroups := make([]map[string]interface{}, 0, len(packageRoutes))
	for pkg, routes := range packageRoutes {
		packageGroups = append(packageGroups, map[string]interface{}{
			"PackageName": pkg,
			"Routes":      routes,
		})
	}

	return map[string]interface{}{
		"Imports":       imports,
		"Handlers":      handlers,
		"PackageGroups": packageGroups,
	}
}

// inferHandlerInfo 推断处理器信息
func (rg *RouteGenerator) inferHandlerInfo(packageName, handlerType string) (string, string, string) {
	// 解析处理器类型，格式如 "v1.ApiHandle", "oauth.Handle"
	parts := strings.Split(handlerType, ".")
	if len(parts) < 2 {
		// 如果格式不正确，使用默认值
		typeName := "Handle"
		varName := fmt.Sprintf("%sHandle", strings.ToLower(packageName))
		return fmt.Sprintf("%s.%s", packageName, typeName), varName, ""
	}

	pkg := parts[0]
	typeName := parts[1]

	// 生成变量名：将类型名转换为小驼峰命名
	// 例如：ApiHandle -> apiHandle, DeptHandle -> deptHandle
	varName := strings.ToLower(string(typeName[0])) + typeName[1:]

	// 根据包名推断导入路径
	// 这里假设项目结构为 bit-labs.cn/flex-admin/app/handle/{package}
	importPath := fmt.Sprintf("bit-labs.cn/flex-admin/app/handle/%s", pkg)

	// 返回完整类型名、变量名和导入路径
	return handlerType, varName, importPath
}
