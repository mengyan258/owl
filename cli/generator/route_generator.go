package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// HandlerInfo 处理器信息
type HandlerInfo struct {
	Type    string `json:"type"`    // 处理器类型
	VarName string `json:"varName"` // 变量名
}

// RouteGenerator 路由生成器
type RouteGenerator struct {
	routes []RouteInfo
}

// NewRouteGenerator 创建新的路由生成器
func NewRouteGenerator(routes []RouteInfo) *RouteGenerator {
	return &RouteGenerator{
		routes: routes,
	}
}

// Generate 生成路由注册文件
func (rg *RouteGenerator) Generate(outputPath string) error {
	// 按包分组路由
	packageRoutes := rg.groupRoutesByPackage()

	// 生成路由注册代码
	content, err := rg.generateRouteContent(packageRoutes)
	if err != nil {
		return fmt.Errorf("生成路由内容失败: %v", err)
	}

	// 确保输出目录存在
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %v", err)
	}

	// 写入文件
	return os.WriteFile(outputPath, []byte(content), 0644)
}

// groupRoutesByPackage 按包分组路由
func (rg *RouteGenerator) groupRoutesByPackage() map[string][]RouteInfo {
	packageRoutes := make(map[string][]RouteInfo)

	for _, route := range rg.routes {
		packageRoutes[route.Package] = append(packageRoutes[route.Package], route)
	}

	return packageRoutes
}

// generateRouteContent 生成路由内容
func (rg *RouteGenerator) generateRouteContent(packageRoutes map[string][]RouteInfo) (string, error) {
	tmpl := `// Code generated by owl route scanner. DO NOT EDIT.
package route

import (
	"bit-labs.cn/owl/contract/foundation"
	"github.com/gin-gonic/gin"
{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

// AutoGeneratedRoutes 自动生成的路由注册函数
// 注意：在调用此函数之前，请确保已经调用了 SubAppAdmin.AutoGeneratedBinds() 来注册所有依赖
func AutoGeneratedRoutes(application foundation.Application, appName string) {
	err := application.Invoke(func(
		engine *gin.Engine,
{{- range .Handlers }}
		{{ .VarName }} *{{ .Type }},
{{- end }}
	) {
		// API 路由组
		gv1 := engine.Group("/api/v1")
		
{{- range .PackageGroups }}
		// {{ .PackageName }} 模块路由
		{
{{- range .Routes }}
			// {{ .Summary }}{{ if .Description }} - {{ .Description }}{{ end }}
			gv1.{{ .Method }}("{{ .CleanPath }}", {{ .HandlerCall }})
{{- end }}
		}
{{- end }}
	})
	if err != nil {
		panic(err)
	}
}
`

	data := rg.prepareTemplateData(packageRoutes)

	t, err := template.New("routes").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var buf strings.Builder
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// prepareTemplateData 准备模板数据
func (rg *RouteGenerator) prepareTemplateData(packageRoutes map[string][]RouteInfo) map[string]interface{} {
	// 收集所有处理器和导入
	handlerMap := make(map[string]HandlerInfo)
	importSet := make(map[string]bool)

	// 为每个路由设置处理器变量
	for pkg, routes := range packageRoutes {
		for i, route := range routes {
			handlerType, varName, importPath := rg.inferHandlerInfo(route.Package, route.HandlerType)
			handlerMap[handlerType] = HandlerInfo{
				Type:    handlerType,
				VarName: varName,
			}

			// 收集导入路径
			if importPath != "" {
				importSet[importPath] = true
			}

			// 设置路由的处理器变量和调用方法
			routes[i].HandlerVar = varName
			routes[i].HandlerCall = fmt.Sprintf("%s.%s", varName, route.HandlerMethod)
		}
		packageRoutes[pkg] = routes
	}

	// 转换处理器映射为切片
	handlers := make([]HandlerInfo, 0, len(handlerMap))
	for _, handler := range handlerMap {
		handlers = append(handlers, handler)
	}

	// 转换导入集合为切片
	imports := make([]string, 0, len(importSet))
	for imp := range importSet {
		imports = append(imports, imp)
	}

	// 准备包组数据
	packageGroups := make([]map[string]interface{}, 0, len(packageRoutes))
	for pkg, routes := range packageRoutes {
		packageGroups = append(packageGroups, map[string]interface{}{
			"PackageName": pkg,
			"Routes":      routes,
		})
	}

	return map[string]interface{}{
		"Imports":       imports,
		"Handlers":      handlers,
		"PackageGroups": packageGroups,
	}
}

// inferHandlerInfo 推断处理器信息
func (rg *RouteGenerator) inferHandlerInfo(packageName, handlerType string) (string, string, string) {
	// 解析处理器类型，格式如 "v1.ApiHandle", "oauth.Handle"
	parts := strings.Split(handlerType, ".")
	if len(parts) < 2 {
		// 如果格式不正确，使用默认值
		typeName := "Handle"
		varName := fmt.Sprintf("%sHandle", strings.ToLower(packageName))
		return fmt.Sprintf("%s.%s", packageName, typeName), varName, ""
	}

	pkg := parts[0]
	typeName := parts[1]

	// 生成变量名：将类型名转换为小驼峰命名
	// 例如：ApiHandle -> apiHandle, DeptHandle -> deptHandle
	varName := strings.ToLower(string(typeName[0])) + typeName[1:]

	// 根据包名推断导入路径
	// 这里假设项目结构为 bit-labs.cn/flex-admin/app/handle/{package}
	importPath := fmt.Sprintf("bit-labs.cn/flex-admin/app/handle/%s", pkg)

	// 返回完整类型名、变量名和导入路径
	return handlerType, varName, importPath
}

// GenerateSwaggerDoc 生成 Swagger 文档
func (rg *RouteGenerator) GenerateSwaggerDoc(outputPath string) error {
	swaggerDoc := rg.generateSwaggerJSON()

	// 确保输出目录存在
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %v", err)
	}

	return os.WriteFile(outputPath, []byte(swaggerDoc), 0644)
}

// generateSwaggerJSON 生成 Swagger JSON
func (rg *RouteGenerator) generateSwaggerJSON() string {
	// 这里可以实现完整的 Swagger JSON 生成
	// 为了简化，先返回基本结构
	return `{
  "swagger": "2.0",
  "info": {
    "title": "API Documentation",
    "version": "1.0.0"
  },
  "paths": {}
}`
}

// GenerateRouterInfoFile 生成 RouterInfo 注册文件
func (rg *RouteGenerator) GenerateRouterInfoFile(outputPath string) error {
	content, err := rg.generateRouterInfoContent()
	if err != nil {
		return fmt.Errorf("生成 RouterInfo 内容失败: %v", err)
	}

	// 确保输出目录存在
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %v", err)
	}

	// 写入文件
	return os.WriteFile(outputPath, []byte(content), 0644)
}

// generateRouterInfoContent 生成 RouterInfo 注册内容
func (rg *RouteGenerator) generateRouterInfoContent() (string, error) {
	tmpl := `// Code generated by owl route scanner. DO NOT EDIT.
package route

import (
	"bit-labs.cn/owl/contract/foundation"
	"bit-labs.cn/owl/provider/router"
	"github.com/gin-gonic/gin"
)

// AutoGeneratedRouterInfos 自动生成的 RouterInfo 注册函数
func AutoGeneratedRouterInfos(application foundation.Application, appName string) {
	err := application.Invoke(func(engine *gin.Engine) {
		var routes []*router.RouterInfo
		
{{- range .Routes }}
		// {{ .Summary }}{{ if .Description }} - {{ .Description }}{{ end }}
		routes = append(routes, &router.RouterInfo{
			Method:      "{{ .Method }}",
			Path:        "{{ .Path }}",
			Name:        "{{ .Name }}",
			Module:      "{{ .Module }}",
			Permission:  "{{ .Permission }}",
			Description: "{{ .Description }}",
			Summary:     "{{ .Summary }}",
			Tags:        []string{{ .TagsString }},
			AccessLevel: {{ .AccessLevelCode }},
			AppName:     appName,
		})
{{- end }}

		// 注册所有路由信息到引擎
		for _, routeInfo := range routes {
			// 这里可以添加路由信息到引擎的逻辑
			// 具体实现取决于你的路由管理系统
			_ = routeInfo // 避免未使用变量警告
		}
	})
	if err != nil {
		panic(err)
	}
}
`

	data := rg.prepareRouterInfoTemplateData()

	t, err := template.New("routerinfo").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var buf strings.Builder
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// prepareRouterInfoTemplateData 准备 RouterInfo 模板数据
func (rg *RouteGenerator) prepareRouterInfoTemplateData() map[string]interface{} {
	var routeData []map[string]interface{}

	for _, route := range rg.routes {
		// 生成权限字符串
		permission := rg.generatePermission(route)

		// 生成模块名
		module := rg.generateModule(route)

		// 生成标签字符串
		tagsString := rg.generateTagsString(route.Tags)

		// 生成访问级别代码
		accessLevelCode := rg.mapAccessLevel(route.Access)

		routeData = append(routeData, map[string]interface{}{
			"Method":          route.Method,
			"Path":            route.Path,
			"Name":            route.Name,
			"Module":          module,
			"Permission":      permission,
			"Description":     route.Description,
			"Summary":         route.Summary,
			"TagsString":      tagsString,
			"AccessLevelCode": accessLevelCode,
		})
	}

	return map[string]interface{}{
		"Routes": routeData,
	}
}

// generatePermission 生成权限字符串
func (rg *RouteGenerator) generatePermission(route RouteInfo) string {
	// 格式: appName:module:handlerMethod
	// 例如: admin:api:getAll
	module := strings.ToLower(route.Package)
	method := strings.ToLower(route.HandlerMethod)
	return fmt.Sprintf("admin:%s:%s", module, method)
}

// generateModule 生成模块名
func (rg *RouteGenerator) generateModule(route RouteInfo) string {
	// 使用包名作为模块名，如果有标签则使用第一个标签
	if len(route.Tags) > 0 {
		return route.Tags[0]
	}
	return route.Package
}

// generateTagsString 生成标签字符串
func (rg *RouteGenerator) generateTagsString(tags []string) string {
	if len(tags) == 0 {
		return "{}"
	}

	var quotedTags []string
	for _, tag := range tags {
		quotedTags = append(quotedTags, fmt.Sprintf(`"%s"`, tag))
	}

	return fmt.Sprintf("{%s}", strings.Join(quotedTags, ", "))
}

// mapAccessLevel 映射访问级别
func (rg *RouteGenerator) mapAccessLevel(access string) string {
	switch strings.ToLower(access) {
	case "public", "开放接口":
		return "router.Public"
	case "authenticated", "需要登录":
		return "router.Authenticated"
	case "authorized", "需要授权":
		return "router.Authorized"
	case "adminonly", "admin", "仅超管":
		return "router.AdminOnly"
	default:
		// 默认为需要登录
		return "router.Authenticated"
	}
}
