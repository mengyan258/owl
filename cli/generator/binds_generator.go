package generator

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

// BindsGenerator Binds 生成器
type BindsGenerator struct {
	binds       []BindInfo
	projectPath string
}

// NewBindsGenerator 创建新的 Binds 生成器
func NewBindsGenerator(binds []BindInfo, projectPath string) *BindsGenerator {
	return &BindsGenerator{
		binds:       binds,
		projectPath: projectPath,
	}
}

// Generate 生成 Binds 方法
func (bg *BindsGenerator) Generate(outputPath string) error {
	// 确保输出目录存在
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %v", err)
	}

	// 准备模板数据
	templateData := bg.prepareTemplateData()

	// 生成内容
	content, err := bg.generateBindsContent(templateData)
	if err != nil {
		return fmt.Errorf("生成 Binds 内容失败: %v", err)
	}

	// 写入文件
	if err := os.WriteFile(outputPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("写入文件失败: %v", err)
	}

	// 使用 gofmt 格式化文件
	if err := bg.formatFile(outputPath); err != nil {
		return fmt.Errorf("格式化文件失败: %v", err)
	}

	return nil
}

// BindsTemplateData 模板数据
type BindsTemplateData struct {
	Imports []string
	Binds   []string
}

// prepareTemplateData 准备模板数据
func (bg *BindsGenerator) prepareTemplateData() *BindsTemplateData {
	// 获取项目模块名
	moduleName := bg.getModuleName()

	imports := make(map[string]bool)
	var binds []string

	// 按类型分组并排序
	handleBinds := []string{}
	serviceBinds := []string{}
	repositoryBinds := []string{}

	for _, bind := range bg.binds {
		// 添加导入 - 使用动态模块名
		if bind.Package != "service" && bind.Package != "repository" {
			// handle 包需要导入
			imports[fmt.Sprintf("%s/app/handle/%s", moduleName, bind.Package)] = true
		} else {
			// service 和 repository 包需要导入
			imports[fmt.Sprintf("%s/app/%s", moduleName, bind.Package)] = true
		}

		// 按类型分组
		switch bind.Type {
		case "handle":
			handleBinds = append(handleBinds, bind.ConstructorName)
		case "service":
			serviceBinds = append(serviceBinds, bind.ConstructorName)
		case "repository":
			repositoryBinds = append(repositoryBinds, bind.ConstructorName)
		}
	}

	// 排序
	sort.Strings(handleBinds)
	sort.Strings(serviceBinds)
	sort.Strings(repositoryBinds)

	// 合并所有绑定，按类型顺序：handle -> service -> repository
	binds = append(binds, handleBinds...)
	binds = append(binds, serviceBinds...)
	binds = append(binds, repositoryBinds...)

	// 转换 imports map 为 slice 并排序
	var importSlice []string
	for imp := range imports {
		importSlice = append(importSlice, imp)
	}
	sort.Strings(importSlice)

	return &BindsTemplateData{
		Imports: importSlice,
		Binds:   binds,
	}
}

// generateBindsContent 生成 Binds 内容
func (bg *BindsGenerator) generateBindsContent(data *BindsTemplateData) (string, error) {
	tmpl := `// Code generated by owl route scanner. DO NOT EDIT.

package admin

import (
{{- range .Imports}}
	"{{.}}"
{{- end}}
)

// AutoGeneratedBinds 自动生成的依赖绑定
func (i *SubAppAdmin) AutoGeneratedBinds() []any {
	return []any{
{{- range .Binds}}
		{{.}},
{{- end}}
	}
}
`

	t, err := template.New("binds").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var buf strings.Builder
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// getModuleName 从项目路径获取模块名
func (bg *BindsGenerator) getModuleName() string {
	// 读取 go.mod 文件获取模块名
	goModPath := filepath.Join(bg.projectPath, "go.mod")
	content, err := os.ReadFile(goModPath)
	if err != nil {
		// 如果读取失败，使用默认值
		return "bit-labs.cn/flex-admin"
	}

	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module"))
		}
	}

	// 如果没有找到模块名，使用默认值
	return "bit-labs.cn/flex-admin"
}

// formatFile 使用 gofmt 格式化文件
func (bg *BindsGenerator) formatFile(filePath string) error {
	cmd := exec.Command("gofmt", "-w", filePath)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("gofmt 执行失败: %v", err)
	}
	return nil
}
